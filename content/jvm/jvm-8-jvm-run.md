+++

date = "2021-01-05"

title = "《深入理解JVM》——08.虚拟机类加载机制"

description = "深入理解Java虚拟机第三版"

series = ["book", "jvm"]

+++

## 虚拟机类加载机制

概述
-

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，**在Java语言里，类型的加载、连接和初始化都是在程序运行期完成的**。这种策略让java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一点性能开销，但是却为了Java应用提供了极高的饿扩展性和灵活性，Java天生可以动态扩展的语言特征就是依赖运行期动态加载和动态连接这个特点实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。

# 类加载的时机


![类的生命周期](https://gopher-cn.icu/images/jvm/JVM-class-run-01.png)

JVM规范严格规定了有且只有6中情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）:
1. 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这4条指令的典型Java代码场景有：
    - 使用new关键字实例化对象的时候
    - 读取或设置一个类型的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候
    - 调用一个类型的静态方法的时候
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 
5. 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的的实现类发生了初始化，那该接口要在其之前被初始化。


# 类加载的过程
加载
-

在加载阶段，jvm主要完成以下3件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表着这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

可以说，这三点给开发者提供了很多动态的处理方式，如jar包运行、zip文件运行、war等。jsp文件也会被解析生成class文件。还就就是mysql最原始连接时的类加载，就是在程序运行阶段加载的。

验证
-

目的为了类加载时不要载入有错误或者有恶意企图的字节码使程序崩溃。主要分为以下4个部分：
1. 文件格式验证，字面意思
2. 元数据验证，对类的元数据信息进行语义验证。
3. 字节码验证，通过数据流分析和控制流分析，确定程序语义是合法的。
4. 符号引用验证，验证类的依赖等资源。

准备
-
正式为类中的静态变量初始化值或分配内存的时期。这些变量所使用的内存都应该在方法区中进行分配。JDK 8及之后，类变量会随着对象一起存放在Java堆中，这个时候“类变量在方法区”就完全是一种对逻辑概念的表述了。
> 说明：代码：`public static int value = 123`这段代码在准备阶段后value的值是0，并不是123
而 `public static final int value = 123`这段代码在准备阶段后value的值是123。

解析
-


 


- [目录](../)
- 上一章：[JVM性能监控及故障处理命令](../jvm-7-class-struct)
- 下一节：[Java字节码](../jvm-8-byte-code)


















































