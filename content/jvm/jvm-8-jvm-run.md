+++

date = "2021-01-05"

title = "《深入理解JVM》——08.虚拟机类加载机制"

description = "深入理解Java虚拟机第三版"

series = ["book", "jvm"]

+++

## 虚拟机类加载机制

概述
-

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，**在Java语言里，类型的加载、连接和初始化都是在程序运行期完成的**。这种策略让java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一点性能开销，但是却为了Java应用提供了极高的饿扩展性和灵活性，Java天生可以动态扩展的语言特征就是依赖运行期动态加载和动态连接这个特点实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。

# 类加载的时机


![类的生命周期](https://gopher-cn.icu/images/jvm/JVM-class-run-01)

JVM规范严格规定了有且只有6中情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）:
1. 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这4条指令的典型Java代码场景有：
    - 使用new关键字实例化对象的时候
    - 读取或设置一个类型的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候
    - 调用一个类型的静态方法的时候
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 
5. 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的的实现类发生了初始化，那该接口要在其之前被初始化。


# 类加载的过程
加载
-

在加载阶段，jvm主要完成以下3件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 


- [目录](../)
- 上一章：[JVM性能监控及故障处理命令](../jvm-7-class-struct)
- 下一节：[Java字节码](../jvm-8-byte-code)


















































