+++

date = "2020-11-26"

title = "《深入理解JVM》——03.垃圾收集器理论"

description = "深入理解Java虚拟机第三版"

series = ["book", "jvm"]

+++

垃圾收集器算法
=
因为程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭。所以主要的垃圾收集区域集中在堆区域和方法区，堆里面存放着Java世界中几乎所有对象的实例，垃圾收集器在对堆进行回收之前，第一件事情就是要确认这些对象之中还有哪些“存活”，哪些已经“死去”。

引用计数算法(Reference Counting)
-
对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用实效时，计数器值减一；任何时刻计数器为零的对象就是不可能再被使用的。但在Java主流的虚拟机里都没有使用引用计数算法来实现垃圾回收，因为它很难解决对象之间相互循环引用的问题。

可达性分析算法(Reachability Analysis)
-
![gcroot](https://gopher-cn.icu/images/jvm/gc-root.png)

这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走的路径称为“引用链”(Reference Cain)，如果某个对象到GC Root键没有任何引用链相连，或者用图论的话来说就是从GC Root到这个对象不可达时，则证明此对象是不可能再被使用的。

**在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：**
- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如NPE、OOE）等，还有系统类加载器。
- 所有被同步锁（synchronized）所持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

回收方法区
-
Java堆中，新生代对常规应用进行一次垃圾回收通常可以回收70%至99%的内存空间。

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。
> 举个例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他的地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也类似。

判断一个类型是否属于“不在被使用的类”需要**同时**满足以下三个条件：
- 该类所有的实例都已经被回收
- 加载该类的类加载器已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

垃圾收集算法
=
分代收集理论
-
所谓分代收集理论，实质上一套符合大多数程序运行实际情况的经验法则，它建立在俩个分代假说之上
- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集的对象就越难以消灭。

**收集器应该将Java堆分成不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储**

如果一个区域中大多数对象都是朝生夕灭，我们可以把它们集中在一起，每次回收时**只关注如何保留少量存活的对象，而不是去标记那些大量将要被回收的对象**，这样就能以较低的代价回收到大量的空间； 

如果剩下的都是难以消亡的对象，那把它们集中到一起，虚拟机可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存空间的有效利用。

标记-清除算法（Mark- Sweep）
-
首先标记出所有需要回收的对象，在标记完成之后，统一回收所有被标记的对象，或者所有未被标记的对象。
> 缺点1：效率不稳定，随堆中对象的数量线性增长。

> 缺点2：标记-清除后产生大量不连续的内存碎片，分配大对象时无法找到连续的内存不得不提前触发垃圾回收操作。

标记-复制算法
- 
它将可用内存按容量分为大小相等的两块，没次只使用其中的一块。当这一块的内存用完了，就将**存活的对象复制**到另一块上面，然后再把已使用过的内存空间**一次清理掉**。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销。
> 缺点：可用内存缩小为原来的一半。

标记复制算法的进化-Appel式回收
- 

![Appel式回收](https://gopher-cn.icu/images/jvm/1606700592.jpg)

标记-整理算法（Mark Compact）
-
标记-整理算法，其中的标记过程任然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一段移动，然后直接清理掉边界以外的的内存。

如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存货区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行（Stop The World）

移动对象会使内存回收时更加复杂，不移动会使内存分配时更加复杂。从垃圾回收的角度来说，不移动对象停顿的时间短，甚至不停顿，但是从整个程序的吞吐量来看，移动对象更加划算。所以HotSpot虚拟机中**关注吞吐的Parallel Scavenge收集器是基于标记-整理算法的**，而**关注延迟的CMS收集器是基于标记-清除算法的。**

所以便衍生出了折中的方案，平时多数使用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，在采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的CMS收集器面临空间碎片过多时就是采用这种方法。 

> 出现STW的现象完全是因为内存空间碎片影响了正常的内存分配，所以需要停顿各个线程整理内存空间。

HotSpot算法实现细节
-
准确式垃圾收集。在HotSpot的解决方案里，**是使用一组OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。**这样收集器在扫描时就可以直接得知这些信息了，并不需要一个不漏的从GC Roots开始查找。

安全点-安全区域
-

用户线程在执行过程中可以中断的点和区域，进去此点和此区域即可进行垃圾收集。

> 准确式垃圾收集目标：使用记忆集来缩短GC Roots扫描范围。

并发可达性分析
-

可达性分析算法理论上要求全过程都能保障一致性的快照才能分析，这意味着必须全程冻结用户线程的运行。并发情况下，用户线程同时修改引用关系，会产生将已经消亡的对象标记为存活状态，也可能会产生把原本存活的对象标记为已消亡。要解决并发扫描时的对象消失问题，出现了两种解决方案：增量更新和原始快照。这两种的目的都是将冲突的扫描暂存起来，然后重新扫描。

例如CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现的。

- [目录](../)
- 上一章：[创建对象过程](../jvm-2-new-object-flow)
- 下一节：[各类垃圾收集器分析](../jvm-4-GCer-detail)









