+++

date = "2020-11-18"

title = "《深入理解JVM》——02.创建对象过程"

description = "深入理解Java虚拟机第三版"

series = ["book", "jvm"]

+++

Java虚拟机创建对象的过程
= 

1. jvm遇到第一个new关键字

2. 检查指令的参数是否能在常量池中定位到一个类的符号引用

3. 检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，执行相应的类加载过程。

4. 类加载检查通过后，为新生对象分配内存

   > 为对象分配空间的任务实际上等同于把一块确定大小的内存从Java堆中划分出来。

5. 内存分配完成之后，虚拟机将分配到的内存空间都初始化为零值

6. jvm对对象进行必要的设置，如：对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息。（这些信息都存在对象头之中，Object Header)

7. **从虚拟机的视角来看，一个新的对象已经产生**。但从java程序的视角来看，对象创建才刚刚开始。

8. 一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，java编译器会在遇到new关键字的地方同时生成这俩条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行init()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。


对象的内存布局
=
1. Header（对象头）
2. Instance Data （实例数据）
3. Padding （对齐填充）

Header
- 
第一类用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳。信息长度一般在32比特和64比特（针对不同位数虚拟机），官方承它为“Mark Word”。<br><br>第二类类型指针，即对象指向它的元数据的指针，Java虚拟机通过这个指针来确定该对象是那个类的实例。

Instance Data
-
对象真正存储的有效信息，程序代码里的定义的各种类型的字段内容，父类和子类的字段都会记录。**这部分的存储顺序受到虚拟机分配策略参数（-XX:FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响**

Padding
-
没有特殊含义，仅仅起着占位符的作用

对象的访问定位
=
1. 句柄访问，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和对象类型数据各自具体的地址信息。
2. 直接指针，reference中存储的直接就是对象地址信息。

![pointer1](https://gopher-cn.icu/images/jvm/pointer1.png)<br>

![pointer2](https://gopher-cn.icu/images/jvm/pointer2.png)

- [目录](../)
- 上一章：[基本概念](../jvm-1-base)
- 下一节：[垃圾收集器理论](../jvm-3-GCer)