+++

date = "2020-12-10"

title = "《深入理解JVM》——04.各类垃圾收集器分析"

description = "深入理解Java虚拟机第三版"

series = ["book", "jvm"]

+++

经典垃圾收集器
=
![HotSpot虚拟机的垃圾收集器](https://gopher-cn.icu/images/jvm/HotSpot-1.png)

如果两个收集器之间存在连线，就说明他们可搭配使用。直到目前为止，也没有万能的收集器，只能是在合适的场景下选择合适的收集器。

Serial收集器
-
Serial收集器，从名字就可以看出是单线程工作的收集器，但更重要的是强调他在进行垃圾收集时，必须暂停其他所有的工作。“Stop The World”的理解用一个故事就可以说明：你妈在打扫房间的时候，是不是让你在椅子上或者房间外面待着，如果她一遍打扫，你一边扔纸屑，这个房间永远都打扫不干净了。

迄今为止，它依然是HotSpot虚拟机运行在客户端模式下（用户桌面）的默认**新生代收集器**，与其他单线程收集器比较起来十分简单高效，对于内存资源受限的环境，**它是所有收集器里额外内存消（Memory Footprint）最小的**。因为它不需要和其他线程进行交互，专心只做一件事情。所以说：**Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。**

ParNew收集器
-
ParNew收集器实质上Serial收集器的多线程并行版本，除了使用多线程进行垃圾收集之外，其余行为和控制参数和Serial收集器完全一致。但目前为止只有它能与CMS收集器配合工作。

CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，**它首次实现了让垃圾收集线程和用户线程（基本上）同时工作。**在JDK5中使用CMS来收集老年代的时候，新生代只能选择Serial收集器和ParNew收集器，而ParNew收集器是激活CMS后（使用`-XX:+UseConcMarkSweepGC`选项）的默认新生代收集器，也可以使用`-XX:+/-UseParNewGC`选项来强制指定和禁用。

虽然ParNew十分强大，但随着技术的升级。现在已经被十分NB的G1收集器所取代。G1收集器是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。正所谓：长江后浪推前浪，一代更比一代强，欲知后事如何，请继续看以下讲解的收集器。

Parallel Scavenge收集器
-
Parallel Scavenge也是一款新生代收集器，它同样是标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，与ParNew非常相似。

Parallel Scavenge收集器的特点是**它的关注点与其他收集器不同**，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的吞吐量（Throughput）。

> 吞吐量= {运行用户代码时间} / (运行用户代码时间 + 运行垃圾收集时间)

Parallel Scavenge收集器提供了俩个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数。

> `-XX:MaxGCPauseMillis`这个值并不是设置的越小越好，因为垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的！

Serial Old收集器
-
Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法，**新生代采用复制算法暂停所有用户线程，老年代采用标记-整理算法暂停所有用户线程**。这个收集器的主要意义也是提供客户端模式下的HotSpot虚拟机使用。
使用场景如下：

1. 在JDK5以及之前的版本中与Parallel收集器搭配使用
2. 作为CMS收集器发生失败时的后背预案，在并发收集Concurrent Mode Failure时使用


Parallel Old收集器
-
是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

**CMS收集器(jdk8中重点使用的收集器，我司正在使用)**
-

CMS(Concurrent Mark Sweep)收集器是一种**以获取最短停顿时间为目标**的收集器。因为目前大部分java应用都是基于浏览器的B/S系统的服务端，这类服务较为关注服务的响应速度，希望系统停顿时间尽可能短，已给用户带来友好的体验。

从名字看以看出它是基于标记-清除算法实现的。整个过程分为以下四部分：
1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

> 其中初始标记、重新标记这两个步骤仍然需要“stop the world”。

**初始标记**仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；

**并发标记**阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时很长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；

**重新标记**则是为了修正并发标记期间，因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；

**并发清除**，清理删除标记阶段的判断已经死亡的对象，由于不需要移动存活的对象，所以这个阶段是可以与用户线程同时并发的。

为说明，特将书中的收集器运行图画出便于理解。

![CMS收集器示意图](https://gopher-cn.icu/images/jvm/HotSpot-2.png)

虽然设计的如此强大，但还是有很多缺点，此时此刻我不禁想吟诗一首...
> 明月几时有？把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间！转朱阁，低绮户，照无眠。不应有恨，何事偏向别时圆？**人有悲欢离合，月有阴晴圆缺，此事古难全**。但愿人长久，千里共婵娟。  ——苏轼《水调歌头 明月几时有》  

 在并发阶段，虽然不会导致用户线程停顿，但却会因为占用了一部分线程（处理器的计算能力）而导致程序变慢，降低吞吐量。

由于CMS是一种基于“标记-清除”的算法实现的，所以在垃圾收集完成之后会产生大量的空间碎片，空间碎片太多时，会影响对大对象的内存分配，而不得已提前触发一次Full GC。为了解决这个问题，CMS提供了一个-XX:+UseCMS-CompactAtFullCollection开关参数，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程。

**Garbage First 收集器(G1)**
-
Garbage First(简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果。**它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式**，JDK 8 Update 40之后，G1提供并发的类卸载的支持，这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”（Full-Featured Garbage Collector）

G1是一款主要面向服务端应用的垃圾收集器。JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。

作为CMS收集器的代替者和继承人，设计者们希望做出一款能够建立起“停顿时间模型”的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是实时Java的中软实时垃圾收集的特征了。

在G1收集器出现之前的所有其他的收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），在要么就是整个Java堆（Full GC）。而G1跳出了这个牢笼，**它可以面向堆内存任何部分来组成回收集（Collection Set,简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾最多，回收收益最大，这就是G1的Mixed GC模式。**

 G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异；G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器可以扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

