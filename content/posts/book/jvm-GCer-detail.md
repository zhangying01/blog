+++

date = "2020-12-10"

title = "《深入理解JVM》——04.各类垃圾收集器分析"

description = "深入理解Java虚拟机第三版"

series = ["book", "jvm"]

+++

经典垃圾收集器
=
![HotSpot虚拟机的垃圾收集器](https://gopher-cn.icu/images/jvm/HotSpot-1.png)

如果两个收集器之间存在连线，就说明他们可搭配使用。直到目前为止，也没有万能的收集器，只能是在合适的场景下选择合适的收集器。

Serial收集器
-
Serial收集器，从名字就可以看出是单线程工作的收集器，但更重要的是强调他在进行垃圾收集时，必须暂停其他所有的工作。“Stop The World”的理解用一个故事就可以说明：你妈在打扫房间的时候，是不是让你在椅子上或者房间外面待着，如果她一遍打扫，你一边扔纸屑，这个房间永远都打扫不干净了。

迄今为止，它依然是HotSpot虚拟机运行在客户端模式下（用户桌面）的默认**新生代收集器**，与其他单线程收集器比较起来十分简单高效，对于内存资源受限的环境，**它是所有收集器里额外内存消（Memory Footprint）最小的**。因为它不需要和其他线程进行交互，专心只做一件事情。所以说：**Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。**

ParNew收集器
-
ParNew收集器实质上Serial收集器的多线程并行版本，除了使用多线程进行垃圾收集之外，其余行为和控制参数和Serial收集器完全一致。但目前为止只有它能与CMS收集器配合工作。

CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，**它首次实现了让垃圾收集线程和用户线程（基本上）同时工作。**在JDK5中使用CMS来收集老年代的时候，新生代只能选择Serial收集器和ParNew收集器，而ParNew收集器是激活CMS后（使用`-XX:+UseConcMarkSweepGC`选项）的默认新生代收集器，也可以使用`-XX:+/-UseParNewGC`选项来强制指定和禁用。

虽然ParNew十分强大，但随着技术的升级。现在已经被十分NB的G1收集器所取代。G1收集器是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。正所谓：长江后浪推前浪，一代更比一代强，欲知后事如何，请继续看以下讲解的收集器。

Parallel Scavenge收集器
-
Parallel Scavenge也是一款新生代收集器，它同样是标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，与ParNew非常相似。

Parallel Scavenge收集器的特点是**它的关注点与其他收集器不同**，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的吞吐量（Throughput）。

> 吞吐量= {运行用户代码时间} / (运行用户代码时间 + 运行垃圾收集时间)

Parallel Scavenge收集器提供了俩个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数。

> `-XX:MaxGCPauseMillis`这个值并不是设置的越小越好，因为垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的！

Serial Old收集器
-
Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法，**新生代采用复制算法暂停所有用户线程，老年代采用标记-整理算法暂停所有用户线程**。这个收集器的主要意义也是提供客户端模式下的HotSpot虚拟机使用。
使用场景如下：

1. 在JDK5以及之前的版本中与Parallel收集器搭配使用
2. 作为CMS收集器发生失败时的后背预案，在并发收集Concurrent Mode Failure时使用


Parallel Old收集器
-
是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

**CMS收集器(重点，主流收集器)**
-

CMS(Concurrent Mark Sweep)收集器是一种**以获取最短停顿时间为目标**的收集器。因为目前大部分java应用都是基于浏览器的B/S系统的服务端，这类服务较为关注服务的响应速度，希望系统停顿时间尽可能短，已给用户带来友好的体验。

从名字看以看出它是基于标记-清除算法实现的。整个过程分为以下四部分：
1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

> 其中初始标记、重新标记这两个步骤仍然需要“stop the world”。

**初始标记**仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；

**并发标记**阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时很长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；

**重新标记**则是为了修正并发标记期间，因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；

**并发清除**，清理删除标记阶段的判断已经死亡的对象，由于不需要移动存活的对象，所以这个阶段是可以与用户线程同时并发的。

为说明，特将书中的收集器运行图画出便于理解。

![CMS收集器示意图](https://gopher-cn.icu/images/jvm/HotSpot-2.png)

虽然设计的如此强大，但还是有很多缺点，此时此刻我不禁想吟诗一首...
> 明月几时有？把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间！转朱阁，低绮户，照无眠。不应有恨，何事偏向别时圆？**人有悲欢离合，月有阴晴圆缺，此事古难全**。但愿人长久，千里共婵娟。  ——苏轼《水调歌头 明月几时有》  

 在并发阶段，虽然不会导致用户线程停顿，但却会因为占用了一部分线程（处理器的计算能力）而导致程序变慢，降低吞吐量。



