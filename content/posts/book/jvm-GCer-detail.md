+++

date = "2020-12-10"

title = "《深入理解JVM》——04.各类垃圾收集器分析"

description = "深入理解Java虚拟机第三版"

series = ["book", "jvm"]

+++

经典垃圾收集器
=
![HotSpot虚拟机的垃圾收集器](https://gopher-cn.icu/images/jvm/HotSpot-1.png)

如果两个收集器之间存在连线，就说明他们可搭配使用。直到目前为止，也没有万能的收集器，只能是在合适的场景下选择合适的收集器。

Serial收集器
-
Serial收集器，从名字就可以看出是单线程工作的收集器，但更重要的是强调他在进行垃圾收集时，必须暂停其他所有的工作。“Stop The World”的理解用一个故事就可以说明：你妈在打扫房间的时候，是不是让你在椅子上或者房间外面待着，如果她一遍打扫，你一边扔纸屑，这个房间永远都打扫不干净了。

迄今为止，它依然是HotSpot虚拟机运行在客户端模式下（用户桌面）的默认**新生代收集器**，与其他单线程收集器比较起来十分简单高效，对于内存资源受限的环境，**它是所有收集器里额外内存消（Memory Footprint）最小的**。因为它不需要和其他线程进行交互，专心只做一件事情。所以说：**Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。**

ParNew收集器
-
ParNew收集器实质上Serial收集器的多线程并行版本，除了使用多线程进行垃圾收集之外，其余行为和控制参数和Serial收集器完全一致。但目前为止只有它能与CMS收集器配合工作。

CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，**它首次实现了让垃圾收集线程和用户线程（基本上）同时工作。**在JDK5中使用CMS来收集老年代的时候，新生代只能选择Serial收集器和ParNew收集器，而ParNew收集器是激活CMS后（使用`-XX:+UseConcMarkSweepGC`选项）的默认新生代收集器，也可以使用`-XX:+/-UseParNewGC`选项来强制指定和禁用。

虽然ParNew十分强大，但随着技术的升级。现在已经被十分NB的G1收集器所取代。G1收集器是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。正所谓：长江后浪推前浪，一代更比一代强，欲知后事如何，请继续看以下讲解的收集器。

Parallel Scavenge收集器
-
Parallel Scavenge也是一款新生代收集器，它同样是标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，与ParNew非常相似。

Parallel Scavenge收集器的特点是**它的关注点与其他收集器不同**，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的吞吐量（Throughput）。

> 吞吐量= {运行用户代码时间} / (运行用户代码时间 + 运行垃圾收集时间)

Parallel Scavenge收集器提供了俩个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数。

> `-XX:MaxGCPauseMillis`这个值并不是设置的越小越好，因为垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的！

Serial Old收集器
-
Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义